# Что такое хороший код

Самое важное при написании кода — помнить, что он пишется **для людей**. Это значит, что он должен быть максимально понятным и читабельным, требовать минимум времени на понимание и на внесение изменений. Давай разберем, что именно надо делать для этого: 

### Читабельные имена

Имена переменных, функций, классов должны быть максимально понятными. В идеале не глядя на код функции или содержимое переменной, должно быть очевидно что она делает или хранит.

### Отвечай за слова

Функция должна делать ровно то, что написано в ее названии. Переменная или поле должны хранить ровно то, что написано в названии. Это позволяет читать код, не тратя время на изучение кода функции или поиск, что записывается в переменную.

### Не называй одну и ту же вещь по-разному

Если переменная и поле объекта хранят одно и то же, они должны называться одинаково:

```php
$name = $_POST['name'];
$user->name = $name;
$user->setName($name);

$userManager = new UserManager;
```

Допустимое исключение - когда используются разные стили написания. Например, мы можем называть переменную $userName, а поле в базе данных user_name.

### Не храни 2 разных вещи в одной переменной

Неправильно, например, хранить в одной переменной сначала число очков, а затем 

### Не множь сущности без необходимости

### Результат функции

Функция или метод должны либо вернуть точный и актуальный результат, либо выбросить исключение если они не могут это сделать по каким-то причинам. Такое исключение обычно завершает программу и является сигналом для программиста, что в программе есть ошибка, надо найти ее и исправить.

### Избегай побочных эффектов

Хорошо написанная функция получает все нужные ей данные из аргументов (метод может еще использовать данные из полей объекта). Побочные эффекты - это случаи, когда функция или метод ведут себя не очевидно. Например: 

- функция использует глобальную переменную. Если не поместить в эту переменную заранее нужное значение, функция сработает неправильно и вернет неверный результат. 
- функция или метод работает правильно только если перед ней был вызван какой-то другой метод.

Такие вещи невозможно угадать, глядя на заголовок функции, потому можно вызвать ее не так, как задумано, и получить ошибку или неверный результат. Такого быть не должно. Функция должна всегда возвращать актуальный и точный результат, либо выбросить исключение если это сделать невозможно. Не должно быть ситуаций, когда функция возвращает неправильный результат.

Примеры плохого кода. Глядя на заголовок, можно подумать, что 
результат выполнения функции зависит только от данных пользователя и числа `$points`. 
Но на самом деле он зависит от данных, указанных в `$_GET`. Если же там нет 
нужных данных, данные не будут сохранены в базу:

```php
// Пример плохого кода
/**
 * Добавляет указанное число очков на счет пользователя
 */
function giveBonusPoints(User $user, $points)
{
    $currentPoints = getUserPointsFromDb($_GET['id']);
    $currentPoints += $points;

    // сохраняет число очков в базе
    saveUserPointsInDb($_GET['id'], $currentPoints);
    $user->setPoints($currentPoints);
}
```

Второй пример. Функция `getBonusPoints()`, судя по названию, возвращает число бонусных очков. Однако если не вызвать функцию `init()` перед ней, она вернет ноль. Это неправильно и ведет к ошибкам. В данном случае надо либо добавить вызов функции `init()` в конструктор (чтобы она гарантированно вызывалась при создании объекта), либо избавиться от свойства `$bonusPoints` и вычислять значение прямо в `getBonusPoints()`.

```php
class BonusCalculator
{
    private $bonusPoints = 0;

    public function init()
    {
        $this->bonusPoints = 1;

        // Нет ли тут ошибки в 2 вызовах?
        if (date('j') == '1' || date('j') == '3') {
            // В 1-й и 3-й день месяца бонус больше
            $this->bonusPoints = 2;
        }
    }

    public function getBonusPoints()
    {
        return $this->bonusPoints;
    }
}

$bonusCalculator = new BonusCalculator;
echo $bonusCalculator->getBonusPoints();
```

### Не злоупотребляй хешированием

Некоторые разработчики, узнав про необычные свойства хеш-функций, начинают использовать их там, где они только мешают. Вот неправильный код сравнения содержимого 2 файлов:

```php
// неправильно
if (md5($content1) == md5($content2)) {
```

В данном случае быстрее сравнить содержимое напрямую чем вычислять криптографический хеш. Применение `md5()` не дает никакой выгоды:

```php
if ($content1 == $content2) {
```

Также, использование `md5` для генерации имен файлов или ключей кеша часто только делает их более нечитаемыми, усложняя отладку впоследствии: 

```php
// неправильно: что мешает сразу time? 
// также, это не позволит загружать более 1 файла в секунду
$filename = md5(time()) . '.jpg'; 

// плохо: нечитаемый ключ
$cacheKey = md5($cityId . $userId . $taskId);

// хорошо: 
$cacheKey = sprintf("city:%d:user:%d:task:%d", $cityId, $userId, $taskId);
```
