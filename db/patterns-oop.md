# Паттерны работы с базой данных

Разберемся, как правильно с применением ООП сохранять и загружать данные из базы. Существуют такие подходы: 

- примитивный подход с использованием PDO/массивов
- ActiveRecord http://design-pattern.ru/patterns/active-record.html
- DataMapper http://design-pattern.ru/patterns/data-mapper.html
- TableDataGateway http://design-pattern.ru/patterns/table-data-gateway.html
- cоставление сложных запросов: Query Builder

Общие принципы, которых надо придерживаться:

- SQL запросы не должны быть размазаны по всему приложению, а должны быть собраны в отдельных классах
- для работы с разными таблицами стоит использовать отдельные классы

## Примитивный подход

В этом варианте мы не используем никаких классов, а просто загружаем/вставляем данные в базу с использованием PDO:

```php
<?php
$query = $pdo->prepare("SELECT * FROM news WHERE categId = :categId LIMIT 20");
$query->execute(array(':categId'    =>  $categId));
$news = $query->fetchAll(); // получаем массив массивов
```

Этот способ не требует создания никаких классов, но он очень ограничен и ведет к плохому коду если в нашем приложении больше 1-2 таблиц: ты начнешь путаться, где какой массив и какие у него поля. В общем, с таким подходом ничего хорошего нам не светит.

Однако этот подход наиболее эффективен при работе с огромным количеством записей. 

Такой подход например поддерживается самим PDO, и компонентом Doctrine DBAL из библиотеки Doctrine 2: <http://www.doctrine-project.org/projects/dbal.html>

## Сущности

Более продвинутый способ — использовать объект для представления информации о какой-то сущности (entity) и сохранять/загружать такие объекты из БД.

Одной записи в таблице в таком случае соответствует один объект-сущность. Например, для работы с таблицей новостей мы можем создать сущность `News`, представляющую собой одну новость: 

```php
<?php

class News
{
    public $id;
    public $title;
    public $text;
    public $categId;
    /**
     * Дата в виде объекта DateTime
     */
    public $date;
    
    /**
     * Возвращает возраст новости в днях
     */
    public function getAgeDays()
    {
        // Находим разницу между сегодня и датой публикации в днях
        $today = new DateTime();
        $interval = $today->diff($this->date);
        return $interval->d;
    }
    /**
     * Проверяет все ли поля заполнены перед вставкой в БД
     */
    public function validate(ErrorList $errors)
    {
        if (!$this->title) {
            $errors->add('title', 'Необходимо указать название новости');
        }
        
        if (!$this->text) {
            $errors->add('text', 'Необходимо заполнить текст новости');
        }
    }
}
```

Заметь, что в класс мы можем поместить вспомогательные методы, работающие с этой новостью — удобно (хотя стоит ли вставлять валидацию в сущность — спорный вопрос, так как в нашем варианте у нее нет доступа к БД и она например не может проверить заголовок на уникальность — чтобы это было возможно, надо переносить валидацию в другое место). Теперь у нас есть новость, давай посмотрим, как можно сохранить или загрузить ее из базы данных.

Код, реализующий загрузку и сохранение сущностей в SQL базу данных еще называется ORM (Object-Relational Mapper). ORM пытаются избавить нас от необходимости писать однотипные примитивные SQL запросы, позволяя нам работать на более высоком уровне.

## ActiveRecord

Это более простой способ. При его использовании методы для сохранения/загрузки сущности из БД добавляются прямо в нее. Чтобы не копипастить их в каждый класс, их обычно добавляют в базовый класс, а сущность наследуют от него. При этом обычно в сущности делается метод, возвращающий информацию о соответствии полей объекта таблице и полям в базе данных (чтобы можно было правильно составить SQL запрос): 

```php
<?php
class News extends ActiveRecordBase
{
    .....
    
    protected function getTableName()
    {
        return 'news'; // имя таблицы с новостями
    }
    
    protected function getFields()
    {
        // список полей, которые отображаются на таблицу
        return array('id', 'title', 'text', 'date', 'categId'); 
    }
    
    /**
     * Вызывается перед вставкой в таблицу
     */
    protected function beforeInsert()
    {
        if (!$this->date) {
            // ставим дату создания если не задана
            $this->date = new DateTime(); 
        }
    }
}
```

Соответственно, вот как выглядит пример поиска записей, вставки и обновления записи:

```php
<?php

$news = new News($pdo); // в некоторых фреймворках передавать объект БД не надо − 
                        // сущность сама берет объект откуда-нибудь

// возвращает массив объектов-новостей
$lastestNews = $news->findLatestNews(); 

// возвращает новость с id = 10
$someNews = $news->getById(10);
// меняем название
$someNews->title = 'Новое название';
// Обновляем запись в БД    
$someNews->save();

$newNews = new News($pdo);
$newNews->title = 'Сенсация!';
$newNews->text = 'Текст новости';
// вставка в БД. После нее поля id и date заполняются автоматически
$newNews->save(); 
```

Такой подход используется, например в Yii 1: http://www.yiiframework.com/doc/guide/1.1/ru/database.ar

Этот подход относительно прост, но он имеет недостаток: мы смешиваем бизнес-логику (методы работы со свойствами новости) и работу с БД в одном классе. Хотя объект-новость вполе может сущестовать и сам по себе. Для решения этой проблемы нам нужен DataMapper.

Описание паттерна: <http://design-pattern.ru/patterns/active-record.html>

## DataMapper

В DataMapper мы выносим код сохранения/загрузки сущностей (и все что связано с базой данных) в отдельный класс. Вот пример такого класса: 

```php
<?php
class NewsMapper
{
    ....
    public function save(News $news) { ... }
    public function getById($id) { ... }
    public function findLatestNews() { ... }
}
```

И вот пример использования: 

```php
<?php
$mapper = new NewsMapper($pdo);
// Поиск новости по id
$someNews = $mapper->getById(10);
// меняем название
$someNews->title = 'Новое название';
// Обновляем запись в БД    
$mapper->save($someNews);

// создание новой
$newNews = new News();
$newNews->title = 'Сенсация!';
$newNews->text = 'Текст новости';
// вставка в БД
$mapper->save($newNews);

// После вставки маппер задает id сущности
echo "Добавлена новость с id={$newNews->id}\n";
```

Если у нас в базе несколько таблиц, то мы делаем несколько мапперов, по одному на каждую. Если требуется делать какие-то действия с несколькими таблицами сразу (скрытие новости и всех комментариев к ней), это иногда делают в маппере, содержащем главную сущность (новость), а иногда в классе-сервисе, находящемся выше уровня мапперов и управляющим ими.

Этот подход используется в ORM Doctrine2: http://odiszapc.ru/doctrine/ Только там Mapper называется Repository.

Описание в каталоге паттернов: <http://design-pattern.ru/patterns/data-mapper.html>

## TableDataGateway

Это что-то напоминающее DataMapper, но некоторые действия с данными (например, обновление записи в базе) могут быть реализованы без объектов-сущностей. Например, в ZF есть `Zend_Db_Table` который его реализует: http://framework.zend.com/manual/1.12/ru/zend.db.table.html — там результаты возвращаются в виде объектов класса `Zend_Db_Table_Row`. Соответственно, для любых сущностей используется один и тот же класс и это сильно напоминает подход с массивами.

Описание: <http://design-pattern.ru/patterns/table-data-gateway.html>

## Query Builder

Query Builder — это не альтернатива перечисленным выше паттернам. Он может использоваться с любым из них и предназначен для тех случаев, когда запрос надо видоизменять в зависимости от значений переменных. Ну предположим, нам надо сделать запрос для поиска объявлений по нескольким характеристикам: раздел (`category_id`), дата (`posted_date`) и id автора (`author_id`), причем любой из критериев может отстутствовать. 

Если ты будешь пытаться собирать запрос по кусочкам, то получится примерно такой сложночитаемый и сложноподдерживаемый код: 

```php
// хорошие дети, не делайте так

// критерии поиска
$criteria = [
    'category_id'   =>  6,
    'posted_date'   =>  '2014-01-01 12:00:00',
    'author_id'     =>  8
];

// Массив значений для плейсхолдеров
$placehoders = [];
$conditions = [];

// Если задан поиск по разделу
if (!empty($criteria['category_id'])) {
    $conditions[] = ' category_id = :category_id  ';
    $placeholders[':category_id'] = $criteria['category_id']; 
}

// ...

// собираем все вместе
$where = implode(' AND ', $conditions);
$whereWord = $conditions ? ' WHERE ' : '';
$sql = 'SELECT * FROM table ' . $whereWord . $where . ' ORDER BY posted_date DESC';

```

В нем легко допустить ошибку. Для решения этойпроблемы придуманы Query Builder, где ты можешь составлять запрос по кусочкам. Вот пример использования Doctrine DBAL ([документация на англ.](http://doctrine-dbal.readthedocs.org/en/latest/reference/query-builder.html)):

```php
$qb = $conn->createQueryBuilder();
$qb->select('*')->
    from('table')->
    orderBy('posted_date', 'DESC');

// Если задан поиск по разделу
if (!empty($criteria['category_id'])) {
    $qb->addWhere('category_id = :category_id');
    $qb->setParameter(':category_id', $criteria['category_id']);
}

// ...

// Выводим запрос
echo "SQL код: {$qb->getSql()}\n";

// Выполняем
$stmt = $qb->execute();

```

Релизация QB есть в Zend2: http://framework.zend.com/manual/current/en/modules/zend.db.sql.html#zend-db-sql-select

И в Doctrine DBAL: http://doctrine-dbal.readthedocs.org/en/latest/reference/query-builder.html

## Doctrine 2

Doctrine 2 — это библиотека реализующая паттерн DataMapper. Ты просто добавляешь в свои сущности аннотации, задающие соответствие полей объектов и полей в базе данных, а Doctrine дает тебе классы-репозитории, которые позволяют загружать и сохранять твои объекты в базу данных. Doctrine 2 — очень мощная и популярная, хотя и непростая для начинающего, библиотека. Чтобы с ней работать, надо понимать саму идею ORM, паттерны UnitOfWork и IdentityMap. И придется много читать мануал по ней.

Напишу еще несколько вещей, которые мы не рассмотрели, но которые есть в больших ORM вроде Doctrine 2:

- свой язык запросов DQL, похожий на SQL
- описание через конфиг или аннотации: ты можешь с помощью специальных комментариев-аннотаций указать, как поля объекта связаны с полями в таблице: http://odiszapc.ru/doctrine/basic_mapping/
- IdentityMap ( http://design-pattern.ru/patterns/identity-map.html ): если ты повторно выбираешь ту же самую сущность из базы, тебе возвращается ссылка на существующую сущность. Доктрина следит чтобы каждая сущность существовала ровно в одном экземпляре, и это помогает избежать противоречий когда есть несколько экземпляров и непонятно в каком из них актуальные данные
- UnitOfWork ( http://design-pattern.ru/patterns/unit-of-work.html ): когда ты делаешь изменения в сущностях, они не сохраняются автоматически. Ты должен явно вызвать метод `flush()` и тогда EntityManager найдет все изменившиеся, новые и удаленные сущности и соответственно обновит/вставит/удалит записи в базе одной транзакцией. 
- работа с ассоциациями (связями). Например, Новость может относиться к Категории и быть помечена Тегами, а также под ней могут быть оставлены Комментарии (у которых в свою очередь есть Авторы). При этом если мы должны иметь возможность создавать такие связи и разрывать их. Представь, как сложно такое реализовать самому (трудно представить? попробуй напиши код).

Doctrine 2 не требует от тебя унаследовать класс-сущность от какого-то базового класса, он позволяет связать любой класс с базой данных — главное чтобы в нем были методы get../set.. для чтения и записи полей. Также, придется потратить время на то, чтобы разобраться, как правильно использовать этот ORM и как настроить в нем кеширование метаданных, чтобы он работал с приемлемой скоростью.

В общем, если у тебя маленькое число таблиц, то ты можешь попробовать обойтись простым DataMapper. Но если у тебя много таблиц, и есть связи между ними то использование Doctrine 2 поможет отойти от написания SQL запросов к манипуляции объектами, сделать код проще и короче и сэкономить твое время. Если же у тебя высоконагруженный проект, то возможно от сложных ORM придется отказаться.
