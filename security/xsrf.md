# Уязвимость XSRF

Эта уязвимость (XSRF, CSRF, Cross-Site Request Forge - межсайтовая подделка запросов) позволяет злоумышленнику, заманив пользователя на свою страницу, отправлять запросы от его имени. Чтобы понять то, что ниже написано, тебе надо знать, как делаются HTML-формы и как они обрабатываются на стороне PHP (что такое `$_POST` и `$_GET`).

Допустим, у тебя на сайте (`bank.example.com`) есть какая-то форма, доступная только залогиненным пользователям. Допустим, ты делаешь сайт банка и это форма перевода денег. Она может выглядеть примерно так: 

```html
<h1>Перевести деньги со счета</h1>
<form action="send.php" method="POST">
    <label>Сумма: <input name="sum" value=""></label>
    <label>Номер счета получателя: <input name="target" value=""></label>
    <input type="submit" value="Отправить">
</form>
```

Скрипт-обработчик этой формы проверяет, залогинен ли пользователь, и если да и у него на счету есть нужная сумма, переводит ее на счет получателя.

Ничего подозрительного, верно? Неужели в такой простой форме из двух полей может быть уязвимость? А она есть.

Разработчик этой формы не учел, что форма может быть отправлена не только с сайта банка, но и с любого другого сайта. Злоумышленник может сделать на своем сайте (`evil.example.com`) страницу с заполненной невидимой формой и яваскриптом (яваскрипт это язык, программы на котором встраиваются в HTML-страницу и выполняются в браузере), который отправляет эту форму при заходе на страницу:

```html
<!-- Указываем в качестве адреса отправки сайт банка и делаем форму 
     невидимой, чтобы не пугать пользователя -->
<form action="http://bank.example.com/send.php" style="display: none;">
    <input type="hidden" name="sum" value="9000">
    <input type="hidden" name="target" value="счет злоумышленника">
</form>
<script>
// код на языке яваскрипт, автоматически отправляющий форму
document.forms[0].submit();
</script>
```

После этого злоумышленнику достаточно любым способом заманить твоего пользователя на свою страницу (например скинув ему ссылку или выложив ссылку на популярном сайте). Если пользователь перейдет по ссылке, сработает яваскрипт на странице и отправит форму на сайт банка от имени пользователя. Если пользователь был в этот момент залогинен, то форма будет обработана и деньги переведены. Разумеется, злоумышленник может предусмотреть отправку формы в цикле, до тех пор, пока счет не будет опустошен.

Конечно, в наше время банки, наученные горьким опытом, требуют подтверждения через другие каналы вроде SMS при переводе денег. Но XSRF можно использовать на любых сайтах, где есть формы. Например, с ее помощью можно рассылать от имени пользователя сообщения в соцсети.

XSRF может использоваться не только с формами. Допустим, на некотором форуме переход по ссылке `http://forum.example.com/logout.php` разлогинивает пользователя. Допустим, на этом форуме в текст сообщения можно вставлять картинки с любым URL. Злоумышленник может запостить «картинку» с URL, ведущим на ссылку разлогинивания, и когда пользователь зайдет на страницу с такой картинкой, его браузер отправит запрос и автоматически разлогинит его.

Атака XSRF может применяться и на сайтах, где нет авторизации пользователей. Допустим, у нас есть сайт, где разыгрывается приз и победитель выбирается голосованием. Голосовать может любой пользователь, без регистрации, но только 1 раз с 1 IP-адреса. Если форма голосования не защищена от CSRF, то злоумышленник может сделать свою страницу с формой, заманивать на нее пользователей и тем самым накруивать голоса.

Надеюсь, ты понял, что это довольно серьезная уязвимость, и надо уметь от нее защищаться. 

## Способ борьбы

Чтобы бороться с отправленной без ведома пользователя формой, скрипт-обработчик на сервере должен отличить запрос, отправленный со своего сайта от запроса, отправленного с чужого. Правильный способ сделать это — выдать каждому пользователю индивидуальный код (токен), который хранится в куках, и вставить этот код в форму. А при проверке данных формы сравнить токены в куках и в `$_POST`. Так как злоумышленник не знает токена пользователя, он не может вставить его в форму на своем сайте и пройти проверку. 

Вот примерный алгоритм. Прежде всего, мы должны при заходе на страницу с формой выдать пользователю куку с токеном (а если она у него есть, продлить ей время жизни):

```
Если (у пользователя нет куки с токеном) {
    $token = генерируем случайный код;
    сохраняем код в куки пользователю;
} иначе {
    $token = код из куки;
    Продлеваем время жизни куки;
}
```

Код должен быть сложным, чтобы злоумышленник не мог его угадать. 32 символа [a-zA-Z0-9] дают около 62<sup>32</sup> = 2×10<sup>57</sup> комбинаций, что делает подбор нереальным.

Время жизни можно ставить от нескольких часов до нескольких дней. Если пользователь не заходит на сайт в течение этого времени, то кука удалится и позже он получит новый токен. Не стоит ставить время слишком маленьким, так как в этом случае у долго заполняющего форму пользователя кука может удалиться и форма не будет принята.

Далее, мы должны при выводе формы добавить скрытое поле с токеном в форму:

```html
<input type="hidden" name="token" value="<?= hmlspecialchars($token, ENT_QUOTES) ?>">
```

Ну и наконец при обработке данных формы мы должны сравнить токен в куках и в данных формы:

```
Если (токен в куках пуст или токен в форме пуст или они не равны) {
    добавляем сообщение об ошибке и не принимаем данные;
}
```

В случае ошибки токена можно просто вывести форму с введенными данными и вывести сообщение с просьбой проверить введенные данные и отправить форму повторно, если они верны. 

Точно так же с помощью токена можно защитить и действия, выполняемые по ссылке (хотя по идее для таких вещей должны использоваться формы). Например, ссылка на страницу разлогинивания с сайта с токеном может выглядеть как `/logout.php?token=abcdef123456` (именно так выглядят ссылки на многих сайтах).

У кук есть флаг `httpOnly`, который запрещает доступ к ним из яваскрипта. Если его включить для куки с токеном, защита будет более надежной.

Если ты используешь фреймворк (вроде Yii или Symfony 2), возможно в его реализации классов для обработки форм есть защита от XSRF. Но ты должен внимательно проерить документацию и HTML код — может быть, защита по умолчанию отключена или требует отдельной настройки.

## Другие методы

Ты можешь увидеть где-то неправильные советы, например: 

- проверять заголовок `Referer`. Это не так надежно, так как некоторые браузеры и прокси могут не передавать этот заголовок, а также, есть способы отправлять форму без него.
- генерировать токен не случайно, а из IP-адреса пользователя. Это может приводить к багам, например если у мобильного пользователя в процессе заполнения формы разорвалось соединение (и телефон переподключился, получив другой IP) то при отправке формы токен не совпадет.

В новых браузерах при каждом запросе отправляется заголовок `Origin`, который говорит о том, с какой страницы отправлена форма. Возможно, в будущем его можно будет использовать вместо токенов.

## Домашнее задание

Зайди на свои любимые сайты (где есть авторизация), открой инструменты разработчика в браузере (Ctrl + Shift + I), изучи формы и ссылки на сайте, свои куки, и попробуй понять, есть на них защита от XSRF или нет.

## Ссылки

- http://habrahabr.ru/post/235247/ - ошибки при реализации защиты от CSRF
- http://habrahabr.ru/post/21626/ - CSRF на вконтакте в 2008 (тогда у них много уязвимостей было)
- http://intsystem.org/812/stripping-referer-in-redirect/ - некоторые варианты обойти проверку через Referer (потому ты должен использовать токены)
