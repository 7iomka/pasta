# Простая задача на PHP

- Требуется знать: PHP, основы ООП, основы баз данных, основы HTML/CSS, формы, таблицы
- Уровень: начинающий
- Время: 3-10 дней

Cделай сайт для регистрации абитуриентов. Он состоит из 2 страниц: список зарегистрированных абитуриентов (главная страница) и форма ввода/редактирования информации о себе. Любой абитуриент может зайти на сайт и добавить себя в список или отредактировать информацию о себе.

Форма содержит поля: имя, фамилия, пол, номер группы (от 2 до 5 цифр или букв), e-mail (должен быть уникален), суммарное число баллов на ЕГЭ (проверять на адекватность), год рождения, местный или иногородний. Данные надо сохранять в БД, все поля обязательны, все поля надо проверять (например нельзя ввести фамилию длиной 200 символов), при ошибке ввода отображать форму с сообщением об ошибке и выделенным красным цветом ошибочным полем, при успешном заполнении — спасибо, данные сохранены, вы можете их отредактировать  или просмотреть список абитуриентов. 

После регистрации сайт должен запомнить пользователя и вместо формы регистрации показывать форму редактирования своих данных. Запомнить пользователя можно с помощью кук, ставить на 10 лет. Надо использовать какой-то код, чтобы нельзя было отредактировать чужие данные.

Список абитуриентов — выводит имя, фамилию, номер группы, число баллов. Выводятся по 50 человек на страницу, сортировка по любому полю делается кликом на заголовок колонк таблицы (по умолчанию по числу баллов вниз). Есть поле поиска, которое ищет сразу по всем строкам таблицы, регистронезависимо (то есть туда можно ввести номер группы либо часть имени/фамилии).

Если ты можешь, то хорошо бы при поиске подсвечивать в таблице найденную часть слова, если нет, то не обязательно.

Вот примерный вид списка: 

```
Список абитуриентов             Поиск: [___________][Найти]

Имя       Фамилия               Номер группы     Баллов [▲]
-----------------------------------------------------------
Иван      Иванов                1010Э            180
Петр      Петров                132М             220
Сидор     Сидоров               0012             250
...
-----------------------------------------------------------

Страницы: [1]  2   3   4   5 

```

Вот примерный вид страницы результатов поиска (она выглядит практически как страница списка): 

```
Поиск абитуриентов               Поиск: [Иван_______][Найти]

Показаны только абитуриенты, найденные по запросу «Иван». 
[Показать всех абитуриентов]

......
```

- HTML-шаблоны должны быть отделены от PHP кода ( http://www.phpinfo.su/articles/practice/shablony_v_php.html )
- Надо использовать ООП. 
- Для работы с базой данных можно использовать PDO и паттерн DataMapper ( http://design-pattern.ru/patterns/data-mapper.html http://habrahabr.ru/post/198450/ ). 
- Желательно использовать autoloading для подключения классов. 
- Для оформления формы и таблицы можно использовать готовый CSS-фреймворк Twitter Bootstrap, но не тащи к нему кучу лишних файлов и плагинов.

Многие начинающие при решении задания делают одни и те же ошибки. Чтобы не повторять их, внимательно прочитай следующий раздел.

## Комментарии, подводные камни и советы

### ООП

Мы используем ООП при решении этой задачи. Если ты его не знаешь, начни с его изучения.

Очевидно, что стоит сделать класс для хранения информации об абитуриенте. Также, понадобится отдельный класс для сохранения/загрузки информации об абитуриентах из базы данных.

### PHP код

Не ставь в конце файлов тег `?>` — за ним легко забыть пробел или перевод строки и это может сломать функции, отправляющие заголовки (`header()`, `setcookie()`, `session_start()`), так как PHP выведет этот пробел, а после вывода хотя бы одного символа отправлять заголовки нельзя.

Не используй короткий открывающий тег `<?` — он может быть отключен. Используй `<?php` и `<?=` для вывода в шаблоне.

Помни, что любые переданные пользователем параметры (`$_COOKIE`, `$_GET`, `$_POST`) могут отсутствовать или содержать что угодно (например, массив вместо строки). Этот код вызовет ошибку обращения к несуществующему индексу массива, если не передать элемент: 

```php
$x = $_POST['x'];
```

А вот этот код — не вызовет, а благодаря использованию `strval` (преобразует любые данные в строку) мы еще защищаемся от случая, когда нам передали массив вместо строки: 

```php
$x = isset($_POST['x']) ? strval($_POST['x']) : '';
```

В программе у тебя скорее всего, будут какие-то настройки, например параметры соединения с базой данных. Вынеси их в отдельный файл, например `config.php`, чтобы их легко было поменять. Не прописывай их прямо в коде.

### Шаблоны

Не смешивай в одном файле логику на PHP и вывод HTML-кода. Это ужасно:

```php
echo "<div class=\"some-class\" style=\"padding-left: 20px;\"><span>...";
```

Такой код тяжело и читать, и редактировать. Весь HTML-код надо вынести в отдельный шаблон, как описано тут: http://www.phpinfo.su/articles/practice/shablony_v_php.html

Не забывай экранировать данные при выводе в шаблоне, иначе получишь уязвимость XSS. Прочитай урок про борьбу с XSS: [security/xss.md](security/xss.md).

Выводить переменные удобнее с помощью тега `<?=` который равносилен `<?php echo `: `<?= html($name) ?>`

Используй в шаблоне версии конструкций `if`/`foreach` c двоеточием, так как версии со скобками плохо читаются в гуще HTML-кода. Мануал: https://php.net/manual/ru/control-structures.alternative-syntax.php

Не пиши логику в шаблонах (например, если тебе надо составить сложную ссылку с несколькими параметрами, лучше сделать отдельную функцию). Не обращайся к внешним переменным вроде `$_GET` из шаблона. Шаблон должен использовать только те переменные, что ему переданы.

### Структура файлов

Удобно в этом задании сделать такую структуру файлов и каталогов: для каждой страницы свой php-скрипт (для страницы со списком и с формой регистрации), каталог с классами и конфигом, каталог с шаблонами (`templates` или `views`).

Если есть какие-то общие действия, которые надо сделать в начале выполнения каждого скрипта — не надо их копипастить. Положи этот код в файл `bootstrap.php` и подключай его через `require`. Копипаста в коде недопустима. Аналогично, если у тебя у двух HTML страниц общая шапка — вынеси это в отдельный файл.

Имена классов пишутся с большой буквы. Каждый класс должен быть в отдельном файле, и ничего другого в этом файле не должно быть. Имя файла должно соответствовать имени класса с точностью до регистра букв (`Student` → `Student.php`). Классы можно сложить в папку с названием `app` или `lib`. 

Не забудь в репозиторий положить SQL дамп с кодом, создающим в базе таблицу. Не надо помещать в дамп команды создания базы данных или пользователя, так как у разных людей они могут быть разные (обычно в программах для работы с базой есть опция для этого).

### Работа с формами

Прочитай [урок по работе с формами](forms.md), где описан универсальный подход для работы с ними.

Формы регистрации и редактирования очень похожи. Не стоит множить сущности, стоит использовать для них общий код.

### MVC

Подход MVC заключается в том, что мы разбиваем приложение на 3 слабо связанных части: Модель (Model), Представление (View) и Контроллер (Controller). 

**Модель** хранит и обрабатывает данные приложения, не взаимодействуя с внешним миром. Например, сохранение информации в БД, проверка правильности введенных данных — это задача Модели, но вывод информации — нет. Модель не должна обращаться к внешним переменным вроде `$_GET`/`$_POST`/`$_SESSION`/`$_COOKIE` и не должна ничего выводить. В этой задаче модель может состоять из классов, описывающих абитуриента и работающих с БД.

**Представление** отображает данные. Оно не должно обращаться к внешним переменным или к базе данных, его задача просто выводить те данные, которые ему передал контроллер. В этой задаче представление скорее всего будет содержать только шаблоны.

**Контроллер** отвечает за взаимодействие с внешним миром (пользователем) и управление всем процессом. Обычно контроллер разбирает параметры запроса из `$_POST`/`$_GET`, обращается к модели, чтобы получить какие-то данные или сделать какое-то действие, и в конце вызывает Представление, чтобы отобразить результат. Здесь контроллерами могут быть скрипты, которые отвечают за вывод списка и обработку формы редактирования/регистрации.

Если ты будешь искать в интернете информацию о MVC, учти что этот подход изначально придуман в 80-е годы для десктопных приложений (с окошечками и кнопочками), а не веб-приложений и «MVC для десктопа» чуть-чуть отличается от «MVC для веба», так как десктопные приложения в отличие от PHP-скрипта, не завершаются после вывода  информации на экран, а продолжают работать. Но общие принципы те же.

Если следовать MVC, разделяя код на части, то он будет проще и надежнее. 

### База данных
 
Номер группы (а также номера телефонов, домов, паспортов) в базе данных надо делать строкой, а не числом. Число используется для обозначения количества чего-то или значения какой-то величины. Вот что бывает если считать телефон числом: http://habrahabr.ru/post/113435/

При проектировании таблицы не забудь проставить для колонок `NULL` или `NOT NULL`. Обычно если у колонки есть значение по умолчанию или для нее разрешен `NULL`, она считается необязательной к заполнению, а если значения по умолчанию нет и `NULL` запрещен, то обязательной.

Ты можешь добавлять к таблице и отдельным колонкам комментарии: http://stackoverflow.com/a/200033 Эти комментарии сохраняются в базе и выводятся в программах для работы с ней. Добавляй комментарии там, где назначение колонки не очень очевидно.

Для колонок с несколькими вариантами значений, вроде «пол», надо использовать тип `ENUM`. Перечитай список типов данных в MySQL, если ты о нем не знал: http://phpclub.ru/mysql/doc/column-types.html Да, для хранения года тоже предусмотрен специальный тип.

### Работа с базой данных из PHP

В этой задаче необходимо хранить данные в базе. Потому, убедись что ты имеешь хотя бы базовые знания языка SQL. Из PHP с базой данных можно работать через 2 расширения: PDO ([статья на Хабре](http://habrahabr.ru/post/137664/), [мануал](http://php.net/manual/ru/book.pdo.php)) и mysqli ([хабр](http://habrahabr.ru/post/141127/), [мануал](http://php.net/manual/ru/book.mysqli.php)). Расширение mysql устарело. Если ты видишь учебник, где используются устаревшие функции вроде `mysql_query()` — выбрасывай это старье.

У PDO и mysqli есть сильные и слабые стороны, но у PDO есть одно преимущество — он умеет выбрасывать исключения при любых ошибках. А mysqli — нет, и после любого действия ты должен проверять, не произошла ли ошибка, с помощью `if` (иначе ты о ней не узнаешь и будешь долго искать почему программа не работает). К сожалению, режим выброса исключений в PDO отключен по умолчанию, но включить его можно одной строчкой сразу после соединения с БД: 

```php
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```

Мануал: http://php.net/manual/ru/pdo.error-handling.php

При соединении с базой не забудь задать кодировку соединения (в какой кодировке ты отправляешь и получаешь данные). Это удобно сделать с помощью параметра `charset`: http://php.net/manual/ru/ref.pdo-mysql.connection.php (не забудь что в MySQL utf-8 пишется без дефиса: `utf8`).

В MySQLi для задания кодировки есть отдельный метод: http://php.net/manual/ru/mysqli.set-charset.php

Также кодировку можно задать запросом `SET NAMES`.

При написании запросов тебе надо подставлять в них какие-то значения из переменных. Не вставляй данные напрямую, вот так: 

```php
$stmt = $pdo->query("SELECT * FROM table WHERE x = $x"); // Хорошие дети, не делайте так
```

Это открывает путь к уязвимости под названием SQL-инъекция: [wiki: внедрение SQL кода](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_SQL-%D0%BA%D0%BE%D0%B4%D0%B0), [статья на античате](http://forum.antichat.ru/thread43966.html). 

Чтобы уязвимости не было, вставлять все данные в запрос надо через плейсхолдеры:

```php
// Создаем подготовленный запрос
$stmt = $pdo->prepare("SELECT * FROM table WHERE x = :x AND y = :y");

// Привязываем значения переменных
$stmt->bindValue(':x', $x);
$stmt->bindValue(':y', $y);

// Выполяем запрос
$stmt->execute();
```

В некоторых статьях вместо `bindValue` используют `bindParam`, но он менее удобен, так как в него нельзя передать число или выражение (только одну переменную) и он вообще предназначен для двухсторонней привязки, что в 99% случаев не требуется.

Есть определенные паттерны проектирования для сохранения и загрузки объектов из БД. В этом задании удобно сделать это с помощью паттерна DataMapper, который описан в моем уроке: [db/patterns-oop.md](db/patterns-oop.md). 

Когда ты загружаешь данные из базы, тебе надо как-то создать соответствующий им список объектов (заполнение свойств объектов данными из БД называется *hydration*). В простых ситуациях можно использовать встроенную в PDO возможность создавать объекты с помощью `PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE` (пример есть тут: http://php-zametki.ru/php-prodvinutym/57-pdo-konstanty-vyborki-dannyx.html ). PDO в этом режиме создает объект указанного класса и копирует значения из базы в публичные свойства. 

Флаг `PDO::FETCH_PROPS_LATE` нужен, чтобы исправить странность PHP, когда он выставляет свойства до вызова конструктора. Вертикальная черта `|` — это битовый оператор, который используется для объединения флагов (чтобы понять, как это работает, надо знать двоичные числа).

В более сложных случаях (например, когда у объекта нет публичных свойств и их надо задавать через методы) данные можно получить в виде массива и превратить в объект специальным методом в маппере.

Чтобы получить id только что вставленной в базу записи, есть специальная надежная функция [lastInsertId](http://php.net/manual/ru/pdo.lastinsertid.php). Не изобретай велосипедов.

Если тебе надо посчитать число строк в таблице, не вздумай выбирать все записи и пересылать в PHP. Используй функцию `SELECT COUNT(*)`. Аналогично, если тебе надо проверить нет ли такого email в базе, не надо ничего выбирать — достаточно посчитать число записей, где он встречается.

### Проверка ошибок в Mysqli

Если ты используешь mysqli, то практически после каждой функции mysqli должен стоять `if`, проверяющий, не произошла ли ошибка, и выбрасывающий исключение, если это так (если ты используешь PDO, то делать это не требуется, он сам это делает).

По умолчанию, если при работе с БД происходит ошибка, mysqli молчит как партизан и не выводит никаких предупреждений (а только возвращает `false` что мало помогает в поиске причины). Ты не узнаешь об ошибке и удивляешься почему ничего не работает.

Посмотри код в примерах: http://php.net/manual/ru/mysqli.quickstart.statements.php

Видишь, после каждого вызова функций mysqli стоит `if` с выводом сообщения об ошибке? То же самое надо сделать и тебе. Только на реальном сайте ошибку лучше не показывать пользователю, а писать в логи или например выкидывать исключение.

Вот неплохая статья про mysqli и там тоже говорится про обработку ошибок: http://habrahabr.ru/post/141127/

### Строгий режим в MySQL

Строгий режим — это режим, при котором MySQL более тщательно проверяет твои запросы и вместо предупреждений (которые ты не увидишь) в некоторых случаях выдает ошибки (из-за которых программа останавливается). Ну к примеру, если у тебя есть колонка типа `varchar(200)` и ты попытаешься вставить в нее строку из 300 символов, в нестрогом режиме MySQL молча отрежет лишнее (и в базе окажется обрезанная строка), а в строгом выдаст ошибку.

Разумеется, для тебя, как для начинающего это очень полезно. С ним ты увидишь ошибку сразу, а не после того как в твоей базе появится куча неправильных данных. И сэкономишь время на исправлении неправильных данных в БД.

Я советую включать этот режим, сделав при соединении с БД запрос `SET sql_mode='STRICT_ALL_TABLES'`. Если ты используешь PDO то стоит указать этот запрос с помощью опции `PDO::MYSQL_ATTR_INIT_COMMAND` при создании объекта PDO (мануал: http://php.net/manual/ru/ref.pdo-mysql.php ).

- хабр: http://habrahabr.ru/post/116922/
- мануал MySQL (англ): https://dev.mysql.com/doc/refman/5.0/en/sql-mode.html

### Поиск в базе данных

Для поиска в одной колонке по части строки в SQL есть оператор `LIKE`: `WHERE x LIKE '%hello%'` (`%` здесь соответствует любым символам). Для поиска по всем колонкам можно применить оператор `LIKE` к соединенным через  пробел значениям столбцов. Этот способ конечно неэффективен на больших таблицах, но у нас маленькое приложение и незачем что-то усложнять (на больших таблицах используют внешний поисковый движок вроде sphinx).

Другой вариант — искать в нескольких колонках через `OR`, например `name LIKE '%hello%' OR surname LIKE '%hello%'`, но такой способ не сработает при поиске и по имени, и по фамилии одновременно по фразе вроде «Иван Иванов».

Для выделения найденного слова в таблице при выводе можно написать простую функцию, которая получает на вход значение в столбце и окружает найденное слово каким-нибудь HTML-тегом. Не забудь про экранирование символов и `htmlspecialchars`!

### Валидация

Валидация — это проверка введенных данных на правильность. Ты можешь захотеть поместить функцию валидации в класс, представляющий абитуриента. Это не всегда хорошая идея, так как он, например, не может обратиться к базе данных (взаимодействием с базой данных занимается DataMapper). Может быть тогда стоит поместить код валидации в маппер? Это тоже не очень правильно, так как задача маппера работать с базой данных, а не проверять данные на правильность. 

Для валидации вполне можно сделать отдельный класс. Конечно, в маленьких приложениях валидацию можно поместить и в существующий класс, но у нас ведь учебная задача и цель сделать как можно правильнее, а не проще.

Хочешь проверять адрес email с помощью регулярных выражений? Прочти статьи: <http://habrahabr.ru/post/55820/>, <http://habrahabr.ru/post/175375/>

Делай понятные сообщения об ошибках, чтобы пользователь не гадал, что именно он перепутал. Не «неверный формат данных», а «имя не должно быть длиннее 90 символов» (а лучше так: «имя не должно быть длиннее 90 символов, а вы ввели 103») или «в номере группы можно использовать только буквы и цифры» (а еще лучше так: «в номере группы можно использовать только буквы и цифры, а символ '!' нельзя»).

### Составление URL

В задаче требуется обеспечить возможность сортировки и постраничного просмотра результатов поиска. Для этого тебе надо передавать все необходимые параметры в URL, например `list.php?search=cat&sort=name&page=2` (как видишь URL содержит фразу для поиска, номер страницы, направление и колонку для сортировки). Помни, что спецсимволы в параметрах экранируются с помощью [процентного кодирования](https://ru.wikipedia.org/wiki/URL#.D0.9A.D0.BE.D0.B4.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_URL). Это неправильный пример подстановки параметров в ссылку: 

```php
// Если в переменныех есть символы & или #, ссылка сломается
$link = "search.php?q=$query&x=$x"; // Хорошие дети, не делайте так
```

В PHP кодирование спецсимволов для URL делает функция `urlencode()`. Это правильный пример: 

```php
$link = "search.php?q=" . urlencode($query) . "&x=" . urlencode($x);
```

Но удобнее собирать такие ссылки не вручную, а с помощью стандартной функции [http_build_query](http://php.net/manual/ru/function.http-build-query.php). Она собирает строку с параметрами из массива и сама вызывает `urlencode`:

```php
$link = "search.php?" . http_build_query([
    'q'     =>  $query,
    'x'     =>  $x
]);
```

Если ты затем выводишь эту ссылку в HTML-коде, разумеется, надо дополнительно экранировать ее с помощью `htmlspecialchars()`.

Я также советую выносить генерацию ссылок из шаблона в отдельные функции или методы класса, чтобы было примерно так: 

```php
<a href="<?= htmlspecialchars(getSortingLink($search, $dir, $column), ENT_QUOTES) ?>">
```

Так код лучше читается и нам не приходится копипастить ссылки для каждой колонки в таблице.

### Постраничная навигация

В задаче надо выводить студентов (а также результаты поиска) постранично. Для этого стоит использовать SQL-конструкцию `LIMIT X, Y`, которая позволяет выбрать не все, а только Y результатов начиная с X. Чтобы не запутаться что значат X и Y, эту конструкцию удобно писать как `LIMIT Y OFFSET X`. Обрати внимание, что `LIMIT` поддерживается только в MySQL, в других базах данных надо использовать другие конструкции для выборки части результатов.

Также, тебе понадобится посчитать общее число студентов (или результатов поиска) в базе, чтобы узнать число страниц, для этого можно использовать конструкцию `SELECT COUNT(*) FROM ...`. 

Можно сделать удобный класс для расчета числа страниц и формирования ссылок на переход на нужную страницу. В конструктор мы передаем общее число записей, число записей на странице, шаблон для ссылки, после чего может генерировать ссылки для перехода: 

```php
$pager = new Pager($totalPages, $recordsPerPage, 'index.php?page={page}');
echo $pager->getTotalPages();   // считает общее число страниц
echo $pager->getLinkForPage(2); // index.php?page=2
echo $pager->getLinkForLastPage();
```

Когда ты будешь выводить ссылки для страниц, не делай их слишком мелкими или слишком близко друг к другу, так как в этом случае в них будет неудобно нажимать мышью. Если доступна всего одна страница, постраничную навигацию выводить не требуется.

### Авторизация

Нам надо как-то дать возможность абитуриенту редактировать информацию о себе, при этом не дав сделать это злоумышленникам. При этом мы не хотим заставлять абитуриента придумывать и запоминать пароль. Раз так, мы можем сами придумать и сохранить пароль в куки в браузере прозрачно для пользователя.

При регистрации можно генерировать какой-то случайный код, сохраняя его и в базу и в куки пользователю на несколько лет. При попытке редактирования мы можем по коду из кук проверить, имеет ли пользователь право на редактирование данных и если да, то чьих. Код должен быть достаточно сложным, чтобы злоумышленник не мог его подобрать, например 32 символа из диапазона [a-zA-Z0-9] дадут 62<sup>32</sup> ~ 2×10<sup>57</sup> комбинаций, что довольно много.

Такая схема с куками имеет и недостатки: если пользователь возьмет другой браузер или почистит куки, он потеряет доступ к редактированию. Но такая схема вполне подходит для нашего случая.

