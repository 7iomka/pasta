# Автозагрузка, неймспейсы и PSR-4

Когда пишут ООП-код, каждый класс помещают в отдельный файл. Чтобы использовать эти классы, мы должны подключить файлы с ними. Выглядит это примерно так: 

```php
require_once __DIR__ . '/Some/Class.php';
require_once __DIR__ . '/Some/Other/Class.php';
```

(`__DIR__` содержит путь к текущей папке). Когда число классов увеличивается, писать эти require становится неудобно. К счастью, в PHP есть решение проблемы - автозагрузка.

## Автозагрузка

Автозагрузка позволяет тебе зарегистрировать *функцию-автозагрузчик* с помощью функции [spl_autoload_register](http://php.net/manual/ru/function.spl-autoload-register.php). В случае обращения к несуществующему в данный момент классу, PHP будет вызывать зарегистрированные автозагрузчики, передавая им имя класса. Если автозагрузчик знает где лежит этот класс, он должен подключить файл с ним, PHP увидит что класс появился, и прождолжит выполнение программы. Если ни один автозагрузчик не подключит класс, будет выведена ошибка о обращении к несуществующему классу. 

Вот примеры кода, который вызовет срабатывание автозагрузки: 

```php
$a = new A;
B::someMethod();

// Это также вызовет попытку автозагрузки, но если класс не будет
// найден, ошибки не произойдет
if (class_exists('C')) {
// ..    
```

Автозагрузчиков может быть несколько. Например, если ты подключаешь стороннюю библиотеку, то у она может зарегистрировать свой автозагрузчик для ее классов.

Функция-автозагрузчик имеет примерно такой вид:

```php
function ($className) {
    // ...
}
```

Она получает от PHP только имя класса. Для того, чтобы по имени класса можно было понять какой файл надо подключить, обычно используют договоренность. Например, файлы назвают также, как и класс, с точностью до регистра букв: `class SomeClass` -> файл `SomeClass.php`. Одна из таких договоренностей называется PSR-4, о ней ниже.

Помни: 

- автозагрузчик не должен выдавать ошибку если он не может найти файл с классом - может быть, этот класс подгрузит другой автозагрузчик
- не используй функцию `__autoload()`, она устарела много лет назад
- в линуксе регистр букв в именах файлов имеет значение
- в PHP уже есть готовая реализация функции-автозагрузчика [spl_autoload](http://php.net/manual/ru/function.spl-autoload.php)

Пример функции-автозагрузчика: 

```php
spl_autoload_register(function ($class) {
    // Получаем путь к файлу из имени класса
    $path = __DIR__ . $class . '.php';
    if (file_exists($path)) {
        require_once $path;
    }
});
```

Подробнее про автозагрузку можно почитать тут: 

- мануал: http://php.net/manual/ru/function.spl-autoload-register.php
- http://victor.4devs.io/ru/php/classes-autoload-php.html
- http://habrahabr.ru/post/136761/

## Неймспейсы (пространства имен)

Классы можно помещать в так называемые пространства имен (неймспейсы), говоря иначе, полное имя класса может состоять из нескольких частей, которые разделены бекслешем `\\` (не путай с прямым слешем `/`). Например: полное имя `Megasoft\Megacms\SomeClass`, где `Megasoft\Megamcs` - это пространство имен, а `SomeClass` - краткое имя класса. 

Неймспейсы, как и имена классов, принято писать с большой буквы.

Пространства имен решают проблему слишком длинных имен классов. Длинные имена появляются по 2 причинам:

1) борьба с конфликтом имен. Представь что Вася и Петя каждый пишет свои библиотеки и оба решают использовать класс с одинаковым названием, например User. Или функцию getUser(). Если мы попробуем подключить в проекте обе этих библиотеки, будет ошибка так как не может быть 2 классов с одинаковыми именами. Чтобы этого избежать, библиотеки приписывают к классам и функциям свое название в начало:

```
Petya_User
petyaGetUser()
Vasya_User
vasyaGetUser()
Zend_Mail
sfController
```

Если не приписывать в начало имя библиотеки, то конфликт обязательно будет так как в мире тысячи библиотек и в каких-нибудь двух обязательно будут совпадающие названия.

2) большие библиотеки и фрейморки состоят из вложенных друг в друга модулей и компонент и имена классов получаются длиными:

- `Zend_Db_Table_Row_Abstract` — это класс фреймворка Zend Framework 1, модуль Db.
- `sfDatabaseConfigHandler` — класс фреймворка Symfony1, модуль Database

До появления неймспейсов мы имели длинные имена классов. Длинные имена это плохо, так как они увеличивают длину строк и ухудшают читаемость кода.

Неймспейсы решают эту проблему тем, что дают возможность помещать класс (и функции) в неймспейсы:

```
\Symfony\Routing\Router
\Doctrine\ORM\Mapping\Id
\Petya\User
\Vasya\User
```

При этом ты можешь либо писать в коде длинное имя класса со всеми неймспейсами, либо можешь создать синоним через

```php
use \Symfony\Routing\Router;
```

и писать просто `Router`.

По умолчанию, если ты не указываешь неймспейс, то твои классы создаются в глобальном неймспейсе (без добавления префиксов перед именем класса). Чтобы поместить свой класс в неймспейс, надо написать в начале файла с ним `namespace \Some\Name\Space;` . Подробнее неймспейсы и правила работы с ними описаны в мануале: http://php.net/manual/ru/language.namespaces.php

## PSR-4

Когда ты пишешь автозагрузчик, нужны какие-то правила, чтобы узнать по полному имени класса путь к файлу с ним. Желательно, чтобы правила были общие, чтобы каждый разработчик не придумывал свой велосипед.

Эту проблему (как назвать файл с классом) решает рекомендация [PSR-4](http://www.php-fig.org/psr/psr-4/ru/). Она советует называть файл в соответствие с кратким именем класса и класть его в папки, имена которых совпадают с неймспйесами. Например, класс 

`MyLibrary\A\B\C\D`

можно поместить в файл 

`MyLibrary/A/B/C/D.php`

Также, если все наши классы находятся в одном неймспейсе (например MyLibrary), мы можем не создавать для него папку и класть файл с классом в `A/B/C/D.php`

Сам PHP не требует чтобы имя класса совпадало с именем файла, а неймспейсов с именами папок. Ему без разницы где хранится класс. PSR-4 это лишь договоренность, чтобы все использовали общий стандарт. 

Если ты придерживаешься этого стандарта, то во-первых, ты молодец, во-вторых ты можешь не писать свой автозагрузчик, а взять любой готовый автозагручик PSR-4 (например встроенный в композер). Единственное, что тебе надо указать — это корневой неймспейс твоего проекта и корневую папку. Вот пример кода, который надо вписать в `composer.json`, чтобы сказать что классы из неймспейса `MyLibrary` находятся в папке `src`, а классы из `MyApp\Plugins` в `plugins`: 

```json
{
    "autoload": {
        "PSR-4": {
            "MyLibrary": "src/",
            "MyApp\\Plugins": "plugins"
        }
    }
}
```

Мы пишем бекслеш 2 раза, так как таковы правила формата JSON. После того, как ты добавишь информацию в `composer.json`, надо выполнить кодманду `php composer.json dump-autoload`. Она сгенерирует файлы автозагрузчика. Тебе остается только подключить их в своей программе через `require_once __DIR__ . '/vendor/autoload.php;'`. Таким образом, следование PSR-4 и использование композера позволяет нам не писать свой автозагрузчик. 

